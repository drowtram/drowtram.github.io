---
layout:     post
title:      数据结构与算法之美学习笔记
subtitle:   基础篇之二分查找(下)
date:       2019-10-30
author:     Alee
header-img: img/head/binarySearch2.jpg
catalog: true
tags:
    - 数据结构
    - 算法
    - 查找
    - 二分查找
---

## 基础篇之二分查找(下)

> 如何快速定位IP对应的省份地址？



通过IP地址来查找IP归属地的功能并不复杂，它是通过维护一个很大的IP地址库来实现的。地址库中包括IP地址范围和归属地的对应关系。

当我们要查询202.102.133.13这个IP地址归属地时，我们就在地址库中搜索，发现这个IP地址落在[202.102.133.0, 202.102.133.255]这个地址范围内，那我们就可以将这个IP地址范围对应的归属地“山东省东营市”显示给用户了。

```java
[202.102.133.0, 202.102.133.255]  山东东营市 
[202.102.135.0, 202.102.136.255]  山东烟台 
[202.102.156.34, 202.102.157.255] 山东青岛 
[202.102.48.0, 202.102.48.255] 江苏宿迁 
[202.102.49.15, 202.102.51.251] 江苏泰州 
[202.102.56.0, 202.102.56.255] 江苏连云港
```

现在的问题是，在庞大的地址库中逐一比对IP地址所在的区间，是非常耗时的。**假设有12万条这样的IP区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢？**

上一篇二分查找学习的是最简单的一种情况，本篇选择4个典型的案例来介绍二分查找的变形问题。本篇内容默认数据都是从小到大排列为前提。

![4gal](https://static001.geekbang.org/resource/image/42/36/4221d02a2e88e9053085920f13f9ce36.jpg)



#### 变体1:查找第一个值等于给定值的元素

上一节中二分查找是最简单的一种，即有序数据集合中不存在重复的数据，我们在其中查找值等于某个给定值的数据。现在的问题是有序数据集合中存在重复的数据，如何找到第一个值等于给定值的数据，之前的二分查找代码还能继续工作吗？

例如：有如下这样一个有序数组，其中a[5]，a[6]，a[7]的值都等于8，是重复的数据。我们希望查找第一个等于8的数据，也就是下标是5的元素。

![al1](https://static001.geekbang.org/resource/image/50/f8/503c572dd0f9d734b55f1bd12765c4f8.jpg)

如果用之前最简单的二分查找代码实现，首先拿8与区间的中间值a[4]比较，8比6大，于是在下标5到9之间继续查找。下标5和9的中间位置是下标7，a[7]正好等于8，所以代码就返回了。

尽管a[7]也等于8，但它并不是我们要找的第一个等于8的元素。因为第一个值等于8的元素是数组下标为5的元素。所以之前的二分查找代码就无法处理这种情况了。针对这个变形问题，我们可以稍微改造下上一节的代码。

100个人写二分查找就会有100种写法。网上有很多关于变形二分查找的实现代码，有很多写得非常简洁，比如下面这个写法。但是，尽管简洁，理解起来却非常烧脑，也很容易写错。

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid = low + ((high - low) >> 1);
    if (a[mid] >= value) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  
  if (low < n && a[low] == value) return low;
  else return -1;
}
```

看这个实现，理解起来就很烧脑，如果死记硬背这个写法，过几天就全忘了，再写很可能会出错。所以，换一种好理解的写法如下：

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid = low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      if ((mid == 0) || (a[mid - 1] != value)) return mid;
      else high = mid - 1;
    }
  }
  return -1;
}
```

上述代码中，a[mid]跟要查找的value的大小关系有三种情况：大于、小于、等于。对于`a[mid] > value`的情况，就更新`high=mid-1`;对于`a[mid]<value`的情况，就更新`low=mid+1`，这两点比较好理解。当`a[mid]=value`的时候应该如何处理呢？

如果我们查找的是任意一个值等于给定值的元素，当a[mid]等于要查找的值时，a[mid]就是我们要找的元素。但是，这里要求的是找第一个值等于给定值的元素，当a[mid]等于要查找的值时，我们就需要确认一下这个a[mid]是不是第一个值等于给定值的元素。

看第11行代码，如果mid等于0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果mid不等于0，但a[mid]的前一个元素a[mid-1]不等于value，那也说明a[mid]就是我们要找的第一个值等于给定值的元素。

如果经过检查之后发现a[mid]前面的一个元素a[mid-1]也等于value，那说明此时的a[mid]肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新`high=mid-1`，因为要找的元素肯定出现在[low, mid-1]之间。

对比上面的两段代码，后面的代码更好理解。实际上，**很多人都觉得变形的二分查找很难写，主要原因是太追求第一种那样完美、简洁的写法**。而对于我们做工程开发的人来说，代码易读懂、没有bug，其实更重要，所以第二种写法更值得推荐。



#### 变体2:查找最后一个值等于给定值的元素

对于前面查找第一个值等于给定值的元素，我们已经解决了，那如果查找最后一个值等于给定值的元素，该如何解决呢？

根据前面掌握到的方法，可以很轻松地解决这个问题。代码如下：

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid = low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      if ((mid == n - 1) || (a[mid+1] != value)) return mid;
      else low = mid + 1;
    }
  }
  return -1;
}
```

重点还是第11行代码，如果a[mid]这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果a[mid]的后一个元素a[mid+1]不等于value，那也说明a[mid]就是我们要找的最后一个值等于给定值的元素。

如果经过我们检查之后，发现a[mid]后面的一个元素a[mid+1]也等于value，那说明当前这个a[mid]并不是最后一个值等于给定值的元素。我们就更新`low=mid+1`，因为要找的元素肯定出现在[mid+1, high]之间。



#### 变体3:查找第一个大于等于给定值的元素

在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于5的元素，那就是6。

实际上，这个问题的解决思路跟前面的那两种变形问题很类似，代码写起来甚至更简洁。

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid = low + ((high - low) >> 1);
    if (a[mid] >= value) {
      if ((mid == 0) || (a[mid-1] < value)) return mid;
      else high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return -1;
}
```

如果a[mid]小于要查找的值value，那要查找的值肯定在[mid+1, high]之间，所以，我们更新`low=mid+1`。

对于a[mid]大于等于给定值value的情况，我们要先看下这个a[mid]是不是我们要找的第一个值大于等于给定值的元素。如果a[mid]前面已经没有元素，或者前面一个元素小于要查找的值value，那a[mid]就是我们要找的元素。这就是代码第七行的处理逻辑。

如果a[mid-1]也大于等于要查找的值value，那说明要查找的元素在[low, mid-1]之间，所以，我们将high更新为`mid-1`。



#### 变体4:查找最后一个小于等于给定值的元素

比如，数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于7的元素就是6。

有了前面的基础，代码很容易地就能写出来。

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid = low + ((high - low) >> 1);
    if (a[mid] <= value) {
      if ((mid == n - 1) || (a[mid+1] > value)) return mid;
      else low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return -1;
}
```



#### 解答开篇

如何快速定位出一个IP地址的归属地？

如果IP区间与归属地的对应关系不经常更新，我们则可以先预处理这12万条数据，让其按照起始IP从小到大排序。如何来排序呢？由于IP地址可以转化为32位的整型数。所以，我们可以将起始地址按照对应的整型值的大小关系，从小到大进行排序。

然后，这个问题就可以转化为上面的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。

当我们要查询某个IP归属地时，可以先通过二分查找，找到最后一个起始IP小于等于这个IP的IP区间，然后，检查这个IP是否在这个IP区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。



#### 内容小结

上一节提到过，凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或者二叉查找树。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。那二分查找真的没什么用处了吗？

实际上，上一节谈的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。比如本篇这几种变体问题，用其他数据结构，比如散列表、二叉树就比较难实现了。

变体的二分查找算法写起来非常烧脑，很容易因为细节处理不好而产生bug，这些容易出错的细节有：**终止条件、区间上下边界更新方法、返回值选择**。所以最好自己实现一遍，对锻炼编码能力、逻辑思维、写出Bug free代码会很有帮助。



#### 思考

如果有序数组是一个循环有序数组，比如4，5，6，1，2，3。针对这种情况，如何实现求一个“值等于给定值”的二分查找算法呢？



