---
layout:     post
title:      数据结构与算法之美学习笔记
subtitle:   基础篇之排序(上)
date:       2019-10-14
author:     Alee
header-img: img/head/sort1.jpg
catalog: true
tags:
    - 数据结构
    - 算法
    - 排序
    - 冒泡排序
    - 插入排序
    - 选择排序
---

## 基础篇之排序(上)

> 插入排序和冒泡排序的时间复杂度相同，都是O(n²)，在实际的软件开发中，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？



#### 如何分析一个“排序算法”

分析一个排序算法，可以从以下几个方面入手

* **排序算法的执行效率**

  对于排序算法执行效率的分析，从这几个方面来衡量：

  1. **最好情况、最坏情况、平均情况时间复杂度**

     在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度，还得说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。

     > 为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

  2. **时间复杂度的系数、常数、低阶**

     时间复杂度反映的是数据规模n很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但实际软件开发中，排序的可能是10个、100个、1000个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能比较的时候，我们就要把系数、常数、低阶也考虑进来。

  3. **比较次数和交换（移动）次数**

     基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，在分析排序算法的执行效率的时候，应该把比较次数和交换次数也考虑进去。

* **排序算法的内存消耗**

  算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。针对排序算法的空间复杂度，有一个新的概念，**原地排序**(Sorted in place)。原地排序算法，就是特指空间复杂度是O(1)的排序算法。

* **排序算法的稳定性**

  仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，有一个重要的度量指标，**稳定性**。这个概念是说，**如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变**。

  举个例子：比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。

  这组数据里有两个3，经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那么这种排序算法就叫作**稳定的排序算法**；如果前后顺序发生变化，那就叫作**不稳定的排序算法**。

  > 或许你有疑问，两个3哪个在前，哪个在后有什么关系呢？稳不稳定又有什么关系呢？为什么要考察排序算法的稳定性呢？

  在真正软件开发中，要排序的往往不是单纯的整数，而是一组对象。需要按照对象的某个key来排序。

  比如：现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果现在有10万条订单数据，希望按照金额从小到大对订单数据排序。对于金额相同的订单，希望按照下单时间从早到晚排序。对于这样一个排序需求，该如何实现呢？

  最先想到的是：先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来简单，但实现起来会很复杂。

  而借助稳定排序算法可以非常简洁地解决。解决思路是：先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后。再用稳定排序算法，按照订单金额重新排序。两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？

  **稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变**。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序后，相同金额的订单仍然保持下单时间从早到晚有序。

  ![ddpx](https://static001.geekbang.org/resource/image/13/59/1381c1f3f7819ae61ab17455ed7f0b59.jpg)

  

#### 冒泡排序(Bubble Sort)

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。

比如：我们要对一组数据 4，5，6，3，2，1，进行从小到大排序。第一次冒泡操作的详细过程如下

![mppx1](https://static001.geekbang.org/resource/image/40/e9/4038f64f47975ab9f519e4f739e464e9.jpg)

经过一次冒泡操作之后，6这个元素已经存储在正确的位置上。要想完成所有数据的排序，只要进行6次这样的冒泡操作就行了。

![mppx2](https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg)

实际上，这个冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用在继续执行后续的冒泡操作。再举个例子：这里给6个元素排序，只需要4次冒泡操作就可以了。

![mppx3](https://static001.geekbang.org/resource/image/a9/e6/a9783a3b13c11a5e064c5306c261e8e6.jpg)

冒泡排序算法的原理比较简单，具体代码如下：

```java
//冒泡排序，a 表示数组， n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
  for (int i = 0; i < n; i++) {
    //提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; j++) {
      if (a[j] > a[j+1]) {
        int temp = a[j];
        a[j] = a[j+1];
        a[j+1] = temp;
        flag = true; //表示有数据交换
      }
    }
    if (!flag) break; //没有数据交换，提前退出。
  }
}
```

**冒泡排序是原地排序吗？**

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度是O(1)，是一个原地排序算法。

**冒泡排序是稳定的排序算法吗？**

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

**冒泡排序的时间复杂度是多少？**

最好情况下，要排序的数据已经是有序的了，只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是O(n)。而最坏情况是，要排序的数据刚好是倒序排列的，我们需要进行n次冒泡操作，所以最坏情况时间复杂度是O(n²)。

![mppx4](https://static001.geekbang.org/resource/image/fe/0f/fe107c06da8b290fb78fcce4f6774c0f.jpg)

那平均情况时间复杂度呢？

平均时间复杂度就是加权平均期望时间复杂度，对于包含n个数据的数组，这n个数据就有n！(n的阶乘)种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。我们可以通过“**有序度**”和“**逆序度**”这两个概念来进行分析。

**有序度**是数组中具有有序关系的元素对的个数。用数学表达式就是这样：

```java
有序元素对: a[i] <= a[j], 如果 i < j。
```

![yxd](https://static001.geekbang.org/resource/image/a1/20/a1ef4cc1999d6bd0af08d8417ee55220.jpg)

同理，对于一个倒序排列的数组，比如6，5，4，3，2，1，有序度是0；对于一个完全有序的数组，比如1，2，3，4，5，6，有序度就是**n\*(n-1)/2**，也就是15。这种完全有序的数组的有序度叫作**满有序度**。

逆序度的定义正好跟有序度相反(默认从小到大为有序)，用数学表达式就是这样：

```java
逆序元素对: a[i] > a[j], 如果 i < j。
```

我们还可以得到一个公式：**逆序度 = 满有序度 - 有序度**。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

就前面的冒泡排序例子来说，要排序的数组的初始状态是4，5，6，3，2，1，其中，有序元素对有(4,5) (4,6) (5,6)，所以有序度是3。n = 6，所以排序完成之后终态的满有序度为n\*(n-1)/2 = 15。

![yxd1](https://static001.geekbang.org/resource/image/88/34/8890cbf63ea80455ce82490a23361134.jpg)

冒泡排序包含两个操作原子，**比较**和**交换**。每交换一次，有序度就加1。不管算法怎么改进，交换次数总是确定的，即为**逆序度，也就是n\*(n-1)/2-初始有序度**。此例就是 15-3=12，要进行12次交换操作。

对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是0，所以要进行n\*(n-1)/2次交换。最好情况下，初始状态的有序度是n\*(n-1)/2，就不需要进行交换。我们可以取个中间值n\*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。

也就是说平均情况下，需要n\*(n-1)/4次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是O(n²)，所以平均情况下的时间复杂度就是O(n²)。

> 这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太过复杂，不太好用。这种不太严格的分析方法在分析快排的时候也会用上。



#### 插入排序(Insertion Sort)

一个有序数组，在往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。

![crpx](https://static001.geekbang.org/resource/image/7b/a6/7b257e179787c633d2bd171a764171a6.jpg)

这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴以上的插入方法，来进行排序，于是就有了插入排序算法。

**插入排序具体是如何借助上面的思想来实现排序的呢？**

首先，我们将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，知道未排序区间中元素为空，算法结束。

如图所示，要排序的数据是4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。

![crpx1](https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg)

插入排序也包含两种操作，一种是**元素的比较**，一种是**元素的移动**。当我们需要将一个数据a插入到已排序区间时，需要拿a与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素a插入。

对于不同的查找插入点方法(从头到尾、从尾到头)，元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。

为什么移动次数就等于逆序度呢？就拿上面的例子画个图。满有序度是n\*(n-1)/2=15，初始序列的有序度是5，所以逆序度是10。插入排序中，数据移动的个数总和也等于10=3+3+4。

![crpx2](https://static001.geekbang.org/resource/image/fd/01/fd6582d5e5927173ee35d7cc74d9c401.jpg)

插入排序的原理就是这样简单，具体实现代码如下：

```java
//插入排序， a 表示数组， n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;
  
  for (int i = 1; i < n; i++) {
    int value = a[i];
    int j = i - 1;
    //查找插入的位置。
    for (; j >= 0; j--) {
      if (a[j] > value) {
        a[j+1] = a[j]; //移动数据
      } else {
        break;
      }
    }
    a[j+1] = value; //插入数据
  }
}
```

**插入排序是原地排序算法吗？**

从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，即这是一个原地排序算法。

**插入排序是稳定的排序算法吗？**

在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

**插入排序的时间复杂度是多少？**

如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好时间复杂度为O(n)。注意，这里是**从尾到头遍历已经有序的数据**。

如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度是O(n²)。

由于在数组中插入一个数据的平均时间复杂度是O(n)。所以对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行n次插入操作，所以平均时间复杂度是O(n²)。



#### 选择排序(Selection Sort)

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![xzpx](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

实现代码如下：

```java
//选择排序， a 表示数组， n 表示数组大小
public static void seletcionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 0; i < n; i++) {
    int min = i;
    for (int j = i + 1; j < n; j++) {
      if (a[j] < a[min]) {
        min = j;
      }
    }
    //数据交换
    if (min != i) {
      int temp = a[min];
      a[min] = a[i];
      a[i] = temp; 
    }
  }
}
```

**选择排序是原地排序算法吗？**

选择排序空间复杂度为O(1)，是一种原地排序算法。

**选择排序的时间复杂度是多少？**

由上述实现代码就知道选择排序的最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度都是O(n²)。

**选择排序是稳定的排序算法吗？**

选择排序是一种**不稳定的排序算法**。从前面的图可知，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

比如5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到的最小元素是2，与第一个5交换位置，那第一个5和中间的5顺序就变了，所以就不稳定了。正是如此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。



#### 解答开篇

冒泡排序和插入排序的时间复杂度都是O(n²)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎？

冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序也一样，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

但是，从代码实现上看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个。

```java
//冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

//插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

如果执行一个赋值语句的时间粗略地计为单位时间(unit_time)，然后分别用冒泡排序和插入排序对同一个逆序度是K的数组进行排序。用冒泡排序，需要K次交换操作，每次需要3个赋值语句，所以交换操作总耗时就是3\*K 单位时间。而插入排序中数据移动操作只需要K个单位时间。

这只是一个理论的分析，为了验证这个理论，针对上面的冒泡排序和插入排序的Java代码，可以写一个性能对比测试程序。

> 随机生成10000个数组，每个数组中包含200个数据，然后在我的机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约750ms才能执行完成，而插入排序只需要280ms左右就可以完成。

```java
import java.util.*;

class Alee {
	public static void main(String[] args) {
		Random random = new Random();
		//随机生成10000个数组
		for (int i = 0; i < 10000; i++) {
			int[] temp = new int[200];
			for (int j = 0; j < 200; j++) {
				temp[j] = random.nextInt();
			}
			//使用冒泡排序 大约需要750ms
			bubbleSort(temp, 200);
			//使用插入排序 只需要280ms左右
//			insertionSort(temp, 200);
		}
	}
	
	//冒泡排序
	public static void bubbleSort(int[] a, int n) {
		if (n <= 1) return;
		for (int i = 0; i < n; i++) {
			//提前退出冒泡循环的标志位
			boolean flag = false;
			for (int j = 0; j < n - i - 1; j++) {
				if (a[j] > a[j+1]) {
					int temp = a[j];
					a[j] = a[j+1];
					a[j+1] = temp;
					flag = true; //表示有数据交换
				}
			}
			if (!flag) break; //没有数据交换，提前退出。
		}
	}
	
	//插入排序
	public static void insertionSort(int[] a, int n) {
		if (n <= 1) return;
		
		for (int i = 1; i < n; i++) {
			int value = a[i];
			int j = i - 1;
			//查找插入的位置。
			for (; j >= 0; j--) {
				if (a[j] > value) {
					a[j+1] = a[j]; //移动数据
				} else {
					break;
				}
			}
			a[j+1] = value; //插入数据
		}
	}
}
```

所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是O(n²)，但是插入排序要比冒泡排序性能更优。插入排序的算法思路也有很大的优化空间，这里是最基础的一种，优化插入排序可以了解下[希尔排序](https://zh.wikipedia.org/wiki/希尔排序)。

```java
//希尔排序
public static void shellSort(int[] arr) {
  int length = arr.length;
  int temp;
  for (int step = length / 2; step >= 1; step /= 2) {
    for (int i = step; i < length; i++) {
      temp = arr[i];
      int j = i - step;
      while (j >= 0 && arr[j] < temp) {
        arr[j + step] = arr[j];
        j -= step;
      }
      arr[j + step] = temp;
    }
  }
}
```



#### 内容小结

分析评价一个排序算法，需要从执行效率、内存消耗和稳定性三个方面来看。这节内容分析了三种时间复杂度是O(n²)的排序算法，冒泡排序、插入排序、选择排序。

![nrxj](https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg)

这三种排序算法，实现代码都非常简单，在实际开发中插入排序会比较用得上。对于小规模数据的排序，三种排序算法用起来都非常高效。但是在大规模数据排序的时候，这个时间复杂度还是算比较高的，所以我们更倾向于采用时间复杂度是O(n㏒n)的排序算法。



#### 思考

这篇文章的三种排序算法都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，相应的时间、空间复杂度是多少？[^1]





[^1]:如果只考虑改变节点位置，不修改链表节点的value值，冒泡排序相比于数组实现，比较次数一致，但是交换操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。所以，时间复杂度和空间复杂度并无明显变化，如果追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。

