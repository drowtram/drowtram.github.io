---
layout:     post
title:      数据结构与算法之美学习笔记
subtitle:   基础篇之排序(上)
date:       2019-10-14
author:     Alee
header-img: img/head/sort1.jpg
catalog: true
tags:
    - 数据结构
    - 算法
    - 排序
    - 冒泡排序
    - 插入排序
    - 选择排序
---

## 基础篇之排序(上)

> 插入排序和冒泡排序的时间复杂度相同，都是O(n²)，在实际的软件开发中，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？



#### 如何分析一个“排序算法”

分析一个排序算法，可以从以下几个方面入手

* **排序算法的执行效率**

  对于排序算法执行效率的分析，从这几个方面来衡量：

  1. **最好情况、最坏情况、平均情况时间复杂度**

     在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度，还得说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。

     > 为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

  2. **时间复杂度的系数、常数、低阶**

     时间复杂度反应的是数据规模n很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但实际软件开发中，排序的可能是10个、100个、1000个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能比较的时候，我们就要把系数、常数、低阶也考虑进来。

  3. **比较次数和交换（移动）次数**

     基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，在分析排序算法的执行效率的时候，应该把比较次数和交换次数也考虑进去。

* **排序算法的内存消耗**

  算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。针对排序算法的空间复杂度，有一个新的概念，**原地排序**(Sorted in place)。原地排序算法，就是特指空间复杂度是O(1)的排序算法。

* **排序算法的稳定性**

  仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，有一个重要的度量指标，**稳定性**。这个概念是说，**如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变**。

  举个例子：比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。

  这组数据里有两个3，经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那么这种排序算法就叫作**稳定的排序算法**；如果前后顺序发生变化，那就叫作**不稳定的排序算法**。

  > 或许你有疑问，两个3哪个在前，哪个在后有什么关系呢？稳不稳定又有什么关系呢？为什么要考察排序算法的稳定性呢？

  在真正软件开发中，要排序的往往不是单纯的整数，而是一组对象。需要按照对象的某个key来排序。

  比如：现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果现在有10万条订单数据，希望按照金额从小到大对订单数据排序。对于金额相同的订单，希望按照下单时间从早到晚排序。对于这样一个排序需求，该如何实现呢？

  最先想到的是：先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来简单，但实现起来会很复杂。

  而借助稳定排序算法可以非常简洁地解决。解决思路是：先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后。再用稳定排序算法，按照订单金额重新排序。两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？

  **稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变**。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序后，相同金额的订单仍然保持下单时间从早到晚有序。

  ![ddpx](https://static001.geekbang.org/resource/image/13/59/1381c1f3f7819ae61ab17455ed7f0b59.jpg)

  

#### 冒泡排序(Bubble Sort)

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。

比如：我们要对一组数据 4，5，6，3，2，1，进行从小到大排序。第一次冒泡操作的详细过程如下

![mppx1](https://static001.geekbang.org/resource/image/40/e9/4038f64f47975ab9f519e4f739e464e9.jpg)

经过一次冒泡操作之后，6这个元素已经存储在正确的位置上。要想完成所有数据的排序，只要进行6次这样的冒泡操作就行了。

![mppx2](https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg)

实际上，这个冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用在继续执行后续的冒泡操作。再举个例子：这个给6个元素排序，只需要4次冒泡操作就可以了。

![mppx3](https://static001.geekbang.org/resource/image/a9/e6/a9783a3b13c11a5e064c5306c261e8e6.jpg)

冒泡排序算法的原理比较简单，具体代码如下：

```java
//冒泡排序，a 表示数组， n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
  for (int i = 0; i < n; i++) {
    //提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; j++) {
      if (a[j] > a[j+1]) {
        int temp = a[j];
        a[j] = a[j+1];
        a[j+1] = temp;
        flag = true; //表示有数据交换
      }
    }
    if (!flag) break; //没有数据交换，提前退出。
  }
}
```

**冒泡排序时原地排序吗？**

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度是O(1)，是一个原地排序算法。

**冒泡排序是稳定的排序算法吗？**

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

**冒泡排序的时间复杂度是多少？**

最好情况下，要排序的数据已经是有序的了，只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是O(n)。而最坏情况是，要排序的数据刚好是倒叙排列的，我们需要进行n次冒泡操作，所以最坏情况时间复杂度是O(n²)。

![mppx4](https://static001.geekbang.org/resource/image/fe/0f/fe107c06da8b290fb78fcce4f6774c0f.jpg)

那平均情况时间复杂度呢？

平均时间复杂度就是加权平均期望时间复杂度，对于包含n个数据的数组，这n个数据就有n！(n的阶乘)种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。我们可以通过“**有序度**”和“**逆序度**”这两个概念来进行分析。

**有序度**是数组中具有有序关系的元素对的个数。用数学表达式就是这样：

```java
有序元素对: a[i] <= a[j], 如果 i < j。
```

![yxd](https://static001.geekbang.org/resource/image/a1/20/a1ef4cc1999d6bd0af08d8417ee55220.jpg)

同理，对于一个倒叙排列的数组，比如6，5，4，3，2，1，有序度是0；对于一个完全有序的数组，比如1，2，3，4，5，6，有序度就是**n\*(n-1)/2**，也就是15。这种完全有序的数组的有序度叫作**满有序度**。

逆序度的定义正好跟有序度相反(默认从小到大为有序)，用数学表达式就是这样：

```java
逆序元素对: a[i] > a[j], 如果 i < j。
```

我们还可以得到一个公式：**逆序度 = 满有序度 - 有序度**。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

就前面的冒泡排序例子来说，要排序的数组的初始状态是4，5，6，3，2，1，其中，有序元素对有(4,5) (4,6) (5,6)，所以有序度是3。n = 6，所以排序完成之后终态的满有序度为n\*(n-1)/2 = 15。

![yxd1](https://static001.geekbang.org/resource/image/88/34/8890cbf63ea80455ce82490a23361134.jpg)

冒泡排序包含两个操作原子，**比较**和**交换**。每交换一次，有序度就加1。不管算法怎么改进，交换次数总是确定的，即为**逆序度，也就是n\*(n-1)/2-初始有序度**。此例就是 15-3=12，要进行12次交换操作。

对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是0，所以要进行n\*(n-1)/2次交换。最好情况下，初始状态的有序度是n\*(n-1)/2，就不需要进行交换。我们可以取个中间值n\*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。

也就是说平均情况下，需要n\*(n-1)/4次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是O(n²)，所以平均情况下的时间复杂度就是O(n²)。

> 这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太过复杂，不太好用。