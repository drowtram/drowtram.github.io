---
layout:     post
title:      数据结构与算法之美学习笔记
subtitle:   基础篇之线性排序
date:       2019-10-22
author:     Alee
header-img: img/head/linearsort.jpg
catalog: true
tags:
    - 数据结构
    - 算法
    - 排序
    - 线性排序
    - 桶排序
    - 计数排序
    - 基数排序
---

## 基础篇之线性排序

> 你知道如何根据年龄快速地给100万用户排序吗？



#### 何为线性排序

排序算法的时间复杂度是线性的算法叫做**线性排序**(Linear Sort)。

本篇介绍三种时间复杂度是O(n)的线性排序：桶排序、计数排序、基数排序。这三个算法都不是基于比较的排序算法，都不涉及元素之间的比较操作。这三种排序算法很容易理解，时间、空间复杂度分析也很简单，但是对要排序的数据要求很苛刻，所以**重点要掌握这些排序算法的适用场景**。



#### 桶排序(Bucket Sort)

桶排序，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

![tpx](https://static001.geekbang.org/resource/image/98/ae/987564607b864255f81686829503abae.jpg)

为什么桶排序的时间复杂度是O(n)？

如果要排序的数据有n个，我们把它们均匀地划分到m个桶内，每个桶内就有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为O(k * ㏒k)。m个桶排序的时间复杂度就是O(m * k *  ㏒k)，因为k=n/m，所以整个桶排序的时间复杂度就是O(n*㏒(n/m))。当桶的个数m接近数据个数n时，㏒(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。

**桶排序看起来很优秀，但它不能代替别的排序算法**。因为桶排序对要排序的数据要求非常苛刻。

首先，要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。

其次，数据在各个桶之间的分布是比较平均的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为O(n㏒n)的排序算法了。

**桶排序比较适合用在外部排序中**。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

比如：有10GB的订单数据，我们希望按照订单金额(假设金额都是正整数)进行排序，但是内存只有几百MB，没办法一次性把10GB的数据全部加载到内存中。我们可以借助桶排序的处理思想来解决这个问题。

我们先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描后得到，订到金额最小是1元，最大是10万元。我们将所有订单根据金额划分到100个桶里，第一个桶我们存储金额在1到1000元之内的订单，第二桶存储金额在1001到2000元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名(00，01，02，...99)。

理想的情况下，如果订单金额在1到10万之间均匀分布，那订单会被均匀划分到100个文件中，每个小文件中存储大约100MB的订单数据，我们就可以将这100个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，只需要按照文件编号，从小到大依次读取每个小文件等订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。

但现实情况可能是，订单金额在1到10万元之间并不一定是均匀分布的，所以10GB订单数据是无法均匀地划分到100个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件还是很大，没法一次性读入内存，这该怎么处理？

针对这些划分之后还是比较大的文件，我们可以继续划分，比如，订单金额在1到1000元之间的比较多，我们就将这个区间继续划分为10个小区间，1到100元，101到200元，201到300元...901到1000元。如果划分之后，101到200元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。



#### 计数排序(Counting Sort)

**计数排序其实是桶排序的一种特殊情况**。当要排序的n个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分成k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

比如：高考查分数，系统会显示我们的成绩以及所在省的排名。如果当地有50万考生，如何通过成绩快速排序得出名次呢？

考生的满分是750分，最小是0分，这个数据的范围很小，所以我们可以分成751个桶，对应分数从0分到750分。根据考生的成绩，我们将这50万考生划分到这751个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了50万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是O(n)。

计数排序的算法思想就是这么简单，跟桶排序非常类似，只是桶的大小粒度不一样。**但为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？**

来看下计数排序的实现方法。假设只有8个考生，分数在0到5分之间。这8个考生的成绩我们放在一个数组A[8]中，它们分别是：2，5，3，0，2，3，0，3。

考生的成绩从0到5分，我们使用大小为6的数组C[6]表示桶，其中下标对应分数。C[6]内存储的不是考生，而是对应的考生个数。我们只需要遍历一遍考生分数，就可以得到如下C[6]的值。

| C[6]元素 |  2   |  0   |  2   |  3   |  0   |  1   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: |
| C[6]下标 |  0   |  1   |  2   |  3   |  4   |  5   |

从这个表格C[6]可以看出，分数为3分的考生有3个，小于3分的考生有4个，所以，成绩为3分的考生在排序之后的有序数组R[8]中，会保存下标4，5，6的位置。

![jspx](https://static001.geekbang.org/resource/image/36/29/361f4d781d2a2d144dcbbbb0b9e6db29.jpg)

那如何快速计算出，每个分数的考生在有序数组中对应的存储位置呢？这个处理方法非常巧妙，一般人很不容易想得到。

思路是这样的：我们对C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数k的考生个数。

![jspx2](https://static001.geekbang.org/resource/image/dd/1f/dd6c62b12b0dc1b3a294af0fa1ce371f.jpg)

有了前面的数据准备之后，现在就开始进行计数排序中最复杂、最难理解的一部分了。



