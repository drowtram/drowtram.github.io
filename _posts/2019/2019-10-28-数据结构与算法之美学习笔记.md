---
layout:     post
title:      数据结构与算法之美学习笔记
subtitle:   基础篇之二分查找(上)
date:       2019-10-28
author:     Alee
header-img: img/head/binarySearch1.jpg
catalog: true
tags:
    - 数据结构
    - 算法
    - 查找
    - 二分查找
---

## 基础篇之二分查找(上)

> 假设我们有1000万个整数数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这1000万个数据中？如果希望这个功能内存空间占用最多不超过100MB，该如何实现呢？



#### 无处不在的二分思想

二分查找是一种非常简单易懂的快速查找算法。例如：猜字游戏，随机0到99之间的数字，猜这个随机数是多少，猜的过程中，每猜一次会告诉你猜大了还是猜小了，直到猜中为止。如何快速猜中这个数字呢？

假设随机出的数字是23，按照下面的步骤试一试。（如果猜测范围的数字有偶数个，中间数有两个，就选择较小的那个。）

![czyx](https://static001.geekbang.org/resource/image/9d/9b/9dadf04cdfa7b3724e0df91da7cacd9b.jpg)

7次就猜出来了。这个例子用的就是二分思想，按照这个思想，即便是猜0到999的数字，最多也只要10次就能猜中。不信的话，可以试一试。

举一个开发中的例子：假设有1000条订单数据，已经按照订单金额从小到大排序，每个订单金额都不同，并且最小单位是元。现在想知道是否存在金额等于19元的订单。如果存在，则返回订单数据，如果不存在则返回null。

最简单的办法当然是从第一个订单开始，一个一个遍历这1000个订单，直到找到金额等于19元的订单为止。但这样查找会比较慢，最坏情况下，可能要遍历完这1000条记录才能找到，那用二分查找能不能更快速地解决呢？

为了方便演示，这里只有10个订单，订单金额分别是：8，11，19，23，27，33，45，55，67，98。

利用二分思想，每次都与区间的中间数据比对大小，缩小查找范围。如下图，其中low和high表示待查找区间的下标，mid表示待查找区间的中间元素下标。

![efcz1](https://static001.geekbang.org/resource/image/8b/29/8bce81259abf0e9a06f115e22586b829.jpg)

看懂这两个例子，二分思想应该也就掌握得很好了。这里总结一下，**二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0**。



#### O(㏒n)惊人的查找速度

二分查找是一种非常高效的查找算法，高效到什么程度呢？我们来分析一下它的时间复杂度。

我们假设数据大小是n，每次查找后数据都会缩小为原来的一半，也就是会除以2。最坏情况下，直到查找区间被缩小为空，才停止。

![efcz2](https://static001.geekbang.org/resource/image/d1/94/d1e4fa1542e187184c87c545c2fe4794.jpg)

可以看出，这是一个等比数列。其中n/2ᵏ=1时，k的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了k次区间缩小操作，时间复杂度就是O(k)。通过n/2ᵏ=1，可以求得k=㏒₂n，所以时间复杂度就是O(㏒n)。

二分查找是目前为止遇到的第一个时间复杂度是O(㏒n)的算法。O(㏒n)这种**对数时间复杂度**是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级O(1)的算法还要高效。

因为㏒n是一个非常“恐怖”的数量级，即便n非常非常大，对应的㏒n也很小。比如n等于2³²，这个数大约是42亿。也就是说，如果我们在42亿个数据中用二分查找一个数据，最多需要比较32次。

我们知道用大O标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1)有可能表示的是一个非常大的常量值，比如O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有O(㏒n)的算法执行效率高。

> 反过来，对数对应的就是指数。有一个非常著名的“阿基米德与国王下棋的故事”，可以自行Google一下，感受下指数的“恐怖”。这也是为什么我们说，指数时间复杂度的算法在大规模数据面前是无效的。



#### 二分查找的递归与非递归实现

实际上，简单的二分查找并不难写，这里注意“简单”二字。后续学到二分查找的变体问题，那才是真正的烧脑。这里先来看如何来写最简单的二分查找。

**最简单的情况**就是**有序数组中不存在重复元素**，用二分查找值等于给定值的数据。最简单的Java实现如下：

```java
/**
 * 二分查找， a表示数组 n表示数组长度 value表示要查找的值
 */
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  
  while (low <= high) {
    int mid = (low + high) / 2; 
    if (a[mid] == value) {
      return mid;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  
  return -1;
}
```

其中，low、high、mid都是指数组下标，其中low和high表示当前查找的区间范围，初始low=0，high=n-1。mid表示[low，high]的中间位置。通过对比a[mid]与value的大小，来更新接下来要查找的区间范围，直到找到或者区间缩小为0，就退出。这里有**3个容易出错的地方**。

1. **循环退出条件**

   注意是low<=high，而不是low<high。

2. **mid的取值**

   实际上，mid=(low+high)/2这种写法是有问题的。如果low和high比较大的话，两者之和就有可能会溢出。改进的方法是将mid的计算方式写成low+(high-low)/2。更进一步，如果要将性能优化到极致的话，可以将这里的除以2操作转化为位运算low+((high-low)>>1)。因为相比除法运算来说，计算机处理位运算要快得多。

3. **low和high的更新**

   low=mid+1,high=mid-1。注意这里的+1和-1.如果直接写成low=mid或者high=mid，就有可能会发生死循环。比如，当high=3，low=3时，如果a[3]不等于value，就会导致一直循环不退出。

注意以上三点，一个简单的二分查找就可以实现了。**实际上，二分查找除了用循环来实现，还可以用递归来实现**，过程也很简单。 Java代码实现如下：

```java
/**
 * 二分查找的递归实现
 * a表示数组，n表示数组长度，value表示要查找的值
 */
public int bsearch(int[] a, int n, int value) {
  return bsearchInternally(a, 0, n - 1, value);
}

private int bsearchInternally(int[] a, int low, int high, int value) {
  if (low > high) return -1;
  
  int mid = low + ((high - low) >> 1);
  if (a[mid] == value) return mid;
  else if (a[mid] < value) {
    bsearchInternally(a, mid+1, high, value);
  } else {
    bsearchInternally(a, low, mid-1, value);
  }
}
```



#### 二分查找应用场景的局限性

虽然二分查找的时间复杂度是O(㏒n)，查找数据的效率非常高。不过，并不是什么情况下都可以用二分查找，它的应用场景是有很大局限性的。那什么情况下适合用二分查找，什么情况下不适合呢？

* **首先，二分查找依赖的是顺序表结构，简单点说就是数组**。

  那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是O(1)，而链表随机访问的时间复杂度是O(n)。所以，如果数据使用链表存储，二分查找的时间复杂度就会变得很高。

  二分查找只能用在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。

* **其次，二分查找针对的是有序数据**。

  二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，需要先排序。而排序的时间复杂度最低是O(n㏒n)。所以，如果针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。

  但是，如果数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。

  所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。针对动态数据集合，如何在其中快速查找某个数据呢？后续学二叉树时将会解决这个问题。

* **然后，数据量太小不适合二分查找**。

  如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为10的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。

  不过，如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。比如，数组中存储的都是长度超过300的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。

* **最后，数据量太大也不适合二分查找**。

  二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，有1GB大小的数据，如果希望用数组来存储，那就需要1GB的连续内存空间。

  这里的“连续”要注意，即便有2GB的内存空间剩余，但是如果这剩余的2GB内存空间都是零散的，没有连续的1GB大小的内存空间，那照样无法申请一个1GB大小的数组。而二分查找就是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。



#### 解答开篇

如何在1000万个整数中快速查找某个整数？

我们的内存限制是100MB，每个数据大小是8字节，最简单的办法就是将数据存储在数组中，内存占用差不多是80MB，符合内存的限制。我们可以先对这1000万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。

这个问题看起来很简单，实际上它暗藏了“玄机”。如果对数据结构和算法有一定了解，知道散列表、二叉树这些支持快速查找的动态数据结构，可能会觉得用散列表和二叉树也可以解决这个问题。但实际上这是不行的。

虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，不管是散列表还是二叉树，都会需要比较多的额外的内存空间。如果用散列表或者二叉树来存储这1000万的数据，用100MB的内存肯定是存不下的。而二分查找底层依赖的是数组，除了数据本身大小，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。



#### 内容小结

二分查找是一种针对有序数据的高效查找算法，它的时间复杂度是O(㏒n)。

二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为0。但是二分查找的代码实现比较容易写错。需要着重掌握它的三个容易出错的地方：循环退出条件、mid的取值，low和high的更新。

二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还要求数据是有序的。对于较小规模的数据查找，直接使用顺序遍历即可，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。



#### 思考

1. 如何编程实现“求一个数的平方根”？要求精确到小数点后6位。
2. 既然数据使用链表存储，二分查找的时间复杂度就会变得很高，那查找的时间复杂度究竟是多少呢？自己推导一下就会深刻地认识到，为何我们会选择用数组而不是链表来实现二分查找了。





