---
layout:     keynote
title:      "RxJava操作符"
subtitle:   "RxJava常用操作符大全"
iframe:     "//aleej.com/keynote_alee/pages/rxjava"
date:       2018-07-14
author:     "Alee"
tags:
    - RxJava
---

> 本篇都是基于RxJava2.0的操作符说明，由于操作符太多，本篇只列举常用的操作符说明



## 创建操作符

1. **create**

   通过实现ObservableOnSubscribe接口的subscribe来创建，该方法有一个事件发射器ObservableEmitter，通过它来向下游发射事件。

   onNext：发射事件

   onComplete：表示事件全部发射完成，后续再调用onNext不生效

   onError：表示事件发射异常，和onComplete相冲突，事件要么全部发射完成，要么异常终止。调用后再onNext发射事件不生效。

   ```java
   Observable.create(new ObservableOnSubscribe<String>() {
               @Override
               public void subscribe(ObservableEmitter<String> emitter) {
                   emitter.onNext("Android");
                   emitter.onNext("iOS");
                   emitter.onNext("Sailfish OS");
                   emitter.onComplete();
                   emitter.onNext("Meego");//不生效
               }
           });
   ```

2. **just**

   把传入的参数依次发射出去

   ```java
   Observable.just("Android","iOS","Sailfish OS")
                   .subscribe(new Consumer<String>() {
                       @Override
                       public void accept(String s) throws Exception {
                           Log.e("Alee",s);
                       }
                   });
   ```

3. **from**

   1. **fromArray**

      把一个可变参数(数组)依次发射出去

      ```java
      Observable.fromArray("Android","iOS","Sailfish OS")
                      .subscribe(new Consumer<String>() {
                          @Override
                          public void accept(String s) throws Exception {
                              Log.e("Alee",s);
                          }
                      });
      ```

   2. **fromFuture**

      ```java
      Observable.fromFuture(Executors.newSingleThreadExecutor().submit(new Callable<String>() {
                public String call() {
                    Thread.sleep(3000);
                    return "Alee";
                }
      	}))
                      .subscribe(new Consumer<String>() {
                          @Override
                          public void accept(String s) {
                              Log.e("Alee",s);
                          }
                      });
      ```

   3. **fromCallable**

      ```java
      Observable.fromCallable(new Callable<String>() {
      
                  @Override
                  public String call() {
                      return "萨拉黑";
                  }
              }).subscribe(new Consumer<String>() {
                  @Override
                  public void accept(String s) {
                      Log.e("Alee",s);
                  }
              });
      ```

   4. **fromIterable**

      ```java
      List<String> list = new ArrayList<>();
              list.add("撒");
              list.add("啦");
              list.add("嘿");
              Observable.fromIterable(list).subscribe(new Consumer<String>() {
                  @Override
                  public void accept(String s) {
                      Log.e("Alee",s);
                  }
              });
      ```

   5. **fromPublisher**

      ```java
      Observable.fromPublisher(new Publisher<String>() {
                  @Override
                  public void subscribe(Subscriber<? super String> s) {
                      s.onNext("Android");
                      s.onNext("iOS");
                      s.onNext("Sailfish OS");
                      s.onComplete();
                      s.onNext("Others");//不生效
                  }
              }).subscribe(new Consumer<String>() {
                  @Override
                  public void accept(String s) {
                      Log.e("Alee",s);
                  }
              });
      ```

4. **timer**

   通过Timer操作符创建一个延迟发射的Observable，发射的是一个Long型的0，等同于Android的Handler中的postDelay()方法。

   ```java
   Observable.timer(3, TimeUnit.SECONDS)
           .subscribe(new Consumer<Long>() {
               @Override
               public void accept(Long aLong) {
                   Log.e("Alee",String.valueOf(aLong)); //打印0
               }
           });
   ```

5. **interval**

   通过interval操作符创建一个可延迟发射且按照固定时间间隔发射自增整数的Observable，一般用来进行倒计时，或者计时器等

   ```java
   //1秒后每间隔一秒发射一个Long值出去 ，数值从0开始，每次加1，一共发射10次
   Observable.interval(1,1,TimeUnit.SECONDS)
       .take(10) //take 只取前10次发射的事件
       .subscribe(new Consumer<Long>() {
           @Override
           public void accept(Long aLong) {
               Log.e("Alee",String.valueOf(aLong));//打印 0 到 9
           }
       });
   ```

6. **repeat**

   通过repeat操作符创建一个重复发射特定数据的Observable。

   ```java
   Observable.just(1).repeat(3).subscribe(new Consumer<Integer>() {
               int count;
               @Override
               public void accept(Integer integer) {//integer 始终等于1
                   Log.e("Alee",String.valueOf(++count));//打印 1 ，2 ，3
               }
           });
   ```

7. **empty**

   创建一个空的(什么事件都不发射的)直接通知完成的Observable

   ```java
   Observable.empty().subscribe(new Observer() {
               @Override
               public void onSubscribe(Disposable d) {
   
               }
   
               @Override
               public void onNext(Object s) {
                   Log.e("Alee",s.toString());//不会走到这儿
               }
   
               @Override
               public void onError(Throwable e) {
   
               }
   
               @Override
               public void onComplete() {
                   Log.e("Alee","complete");//会走到这儿
               }
           });
   ```

8. **error**

   同empty一样，创建一个什么事件都不发射只通知错误的Observable

   ```java
   Observable.error(new Throwable("oops, you have no money")).subscribe(new Observer() {
               @Override
               public void onSubscribe(Disposable d) {
   
               }
   
               @Override
               public void onNext(Object s) {
                   Log.e("Alee",s.toString());
               }
   
               @Override
               public void onError(Throwable e) {
                   Log.e("Alee",e.getMessage());//会走到这儿
               }
   
               @Override
               public void onComplete() {
                   Log.e("Alee","complete");
               }
           });
   ```

9. **never**

   创建一个不发射任何事件且没有任何通知完成或者错误的Observable

   ```java
   Observable.never().subscribe(new Observer() {
               @Override
               public void onSubscribe(Disposable d) {
                   Log.e("Alee","onSubscribe"); //只会走到这儿
               }
               @Override
               public void onNext(Object o) {
                   Log.e("Alee","onNext");
               }
               @Override
               public void onError(Throwable e) {
                   Log.e("Alee","onError");
               }
               @Override
               public void onComplete() {
                   Log.e("Alee","onComplete");
               }
           });
   ```

10. **range**

    创建一个发射指定范围的整型事件的Observable

    ```java
    Observable.range(1,9)
                    .subscribe(new Consumer<Integer>() {
                        @Override
                        public void accept(Integer integer) {
                            Log.e("Alee",String.valueOf(integer)); //打印1-9
                        }
                    });
    ```

11. **defer**

    只有当订阅者订阅后才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅的时候调用Callable的call()方法创建Observable。

    ```java
    Observable.defer(new Callable<ObservableSource<String>>() {
                @Override
                public ObservableSource<String> call() {
                    return Observable.just("hello world");
                }
            }).subscribe(new Consumer<String>() {
                @Override
                public void accept(String s) {
                    Log.e("Alee",s);
                }
            });
    ```



## 合并操作符

1. **concat**

   按照顺序连接多个同事件类型的Observable，比如发射Integer事件的Observable和发射String事件的Observable是不能concat的。另外`a.concatWith(b)`其内部也是调用`Observable.concat(this,b)`。

   ```java
   Observable<String> observable1 = Observable.just("撒","啦");
           Observable<String> observable2 = Observable.just("嘿","哟");
           Observable.concat(observable1,observable2).subscribe(new Consumer<String>() {
               @Override
               public void accept(String s) {
                   Log.e("Alee",s); //打印 撒 啦 嘿 哟
               }
           });
   ```

2. **startWith**

   其内部也是调用concat连接两个Observable，只是把后面的Observable连接到前面而已

   ```java
   Observable.just("爱","你","哟")
                   .startWith("Alee")
                   .subscribe(new Consumer<String>() {
                       @Override
                       public void accept(String s) {
                           Log.e("Alee",s);// 打印 Alee 爱 你 哟
                       }
                   });
   ```

3. **merge**

   顾名思义，就是将多个Observable合并成一个。其与concat不同的地方在于merge不是按照事件顺序而是按照时间线来连接的。需要注意的是，采用merge合并如果遇到异常，则停止发射事件，并发送onError通知。另一个mergeDelayError可以将异常延迟到其他没有错误的Observable发射完成后才发送onError通知。

   ![](https://upload-images.jianshu.io/upload_images/1931185-57219b8f15ee8a93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

   ```java
   Observable observable1 = Observable.create(new ObservableOnSubscribe<Integer>() {
               @Override
               public void subscribe(ObservableEmitter<Integer> emitter) {
                   for (int i = 0; i < 3; i++) {
                       try {
                           Thread.sleep(1000);
                           emitter.onNext(i);
                       } catch (InterruptedException e) {
                           e.printStackTrace();
                           emitter.onError(new Throwable(e.getMessage()));
                       }
                   }
                   emitter.onComplete();
               }
           }).subscribeOn(Schedulers.io());//订阅在io线程
           Observable observable2 = Observable.create(new 				ObservableOnSubscribe<Integer>() {
               @Override
               public void subscribe(ObservableEmitter<Integer> emitter) {
                   for (int i = 10; i <= 30; i+=10) {
                       try {
                           Thread.sleep(1000);
                           emitter.onNext(i);
                       } catch (InterruptedException e) {
                           e.printStackTrace();
                           emitter.onError(new Throwable(e.getMessage()));
                       }
                   }
                   emitter.onComplete();
               }
           }).subscribeOn(Schedulers.io());//订阅在io线程
   //在Android主线程观察接收事件        
   Observable.merge(observable1,observable2).observeOn(AndroidSchedulers.mainThread())
               .subscribe(new Consumer<Integer>() {
               @Override
               public void accept(Integer integer) {
                   Log.e("Alee",String.valueOf(integer));
               }
           });
   ```

   打印结果：

   ```java
   08-20 11:47:19.131 18326-18326/com.aleej.demo E/Alee: 10
   08-20 11:47:19.132 18326-18326/com.aleej.demo E/Alee: 0
   08-20 11:47:20.133 18326-18326/com.aleej.demo E/Alee: 20
   08-20 11:47:20.134 18326-18326/com.aleej.demo E/Alee: 1
   08-20 11:47:21.135 18326-18326/com.aleej.demo E/Alee: 2
   08-20 11:47:21.136 18326-18326/com.aleej.demo E/Alee: 30
   ```

4. **zip**

   组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数量不一样，则以最少的Observable为标准进行压合。

   ![](https://upload-images.jianshu.io/upload_images/1931185-14134e499db9d0c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

   ```java
   Observable<Integer> observable1 = Observable.just(1,2,3,4);
           Observable<String> observable2 = Observable.just("a","b","c");
           Observable.zip(observable1, observable2, new BiFunction<Integer, String, String>() {
               @Override
               public String apply(Integer integer, String s) {
                   return String.format(Locale.getDefault(),"%d->%s",integer,s);
               }
           }).subscribe(new Consumer<String>() {
               @Override
               public void accept(String s) {
                   Log.e("Alee",s); //打印 1->a 2->b 3->c
               }
           });
   ```

5. **combineLatest**

   当两个Observable中的任何一个发射了一个数据时，通过combineLatest组合每个Observable发射的最新数据（共两个数据），然后发射这个函数的结果。和zip类似，区别在于zip只在每个Observable都发射了数据才压合，combineLatest在任何一个Observable发射了数据都进行压合，每次与另一个Observable最近的数据进行压合。

   ![](https://upload-images.jianshu.io/upload_images/1931185-1e60a8bf25b31e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

   ```java
   Observable<Integer> observable1 = Observable.create(new ObservableOnSubscribe<Integer>() {
               @Override
               public void subscribe(ObservableEmitter<Integer> emitter) throws InterruptedException {
                   emitter.onNext(1);
                   Thread.sleep(1000);
                   emitter.onNext(2);
                   Thread.sleep(5000);
                   emitter.onNext(3);
                   Thread.sleep(500);
                   emitter.onNext(4);
                   Thread.sleep(1000);
                   emitter.onNext(5);
                   emitter.onComplete();
               }
           }).subscribeOn(Schedulers.io());
           Observable<String> observable2 = Observable.create(new ObservableOnSubscribe<String>() {
               @Override
               public void subscribe(ObservableEmitter<String> emitter) throws InterruptedException {
                   Thread.sleep(500);
                   emitter.onNext("A");
                   Thread.sleep(1000);
                   emitter.onNext("B");
                   Thread.sleep(1000);
                   emitter.onNext("C");
                   Thread.sleep(100);
                   emitter.onNext("D");
                   emitter.onComplete();
               }
           }).subscribeOn(Schedulers.io());
           Observable.combineLatest(observable1, observable2, new BiFunction<Integer, String, String>() {
               @Override
               public String apply(Integer integer, String s) {
                   return String.format(Locale.getDefault(),"%d%s",integer,s);
               }
           }).observeOn(AndroidSchedulers.mainThread()).subscribe(new Consumer<String>() {
               @Override
               public void accept(String s) {
                   Log.e("Alee",s);
               }
           });
   ```

   打印结果

   ```java
   08-20 14:26:22.447 22751-22751/com.aleej.demo E/Alee: 1A
   08-20 14:26:22.946 22751-22751/com.aleej.demo E/Alee: 2A
   08-20 14:26:23.451 22751-22751/com.aleej.demo E/Alee: 2B
   08-20 14:26:24.457 22751-22751/com.aleej.demo E/Alee: 2C
   08-20 14:26:24.563 22751-22751/com.aleej.demo E/Alee: 2D
   08-20 14:26:27.953 22751-22751/com.aleej.demo E/Alee: 3D
   08-20 14:26:28.459 22751-22751/com.aleej.demo E/Alee: 4D
   08-20 14:26:29.466 22751-22751/com.aleej.demo E/Alee: 5D
   ```



## 过滤操作符

1. **filter**

   通过指定条件过滤数据

   ```java
   Observable.just(1,2,3,4,5)
                   .filter(new Predicate<Integer>() {
                       @Override
                       public boolean test(Integer integer) {
                           return integer % 2 == 0; //只要能被2整除的值
                       }
                   }).subscribe(new Consumer<Integer>() {
               @Override
               public void accept(Integer integer) {
                   Log.e("Alee",String.valueOf(integer)); //打印 2 4
               }
           });
   ```

2. **ofType**

   通过指定类型过滤数据

   ```java
   Observable.just("A",2,"c",4,5.0F,6L,7.77,0x8)
                   .ofType(String.class) //过滤出所有String 类型的值
                   .subscribe(new Consumer<String>() {
                       @Override
                       public void accept(String s) {
                           Log.e("Alee",s); //打印 A c
                       }
                   });
   ```

3. **take**

   只发射开始的前N项数据，或者一定时间内的数据。

   ```java
   Observable.just(1,3,5,7,9)
                   .take(3)//取前三项数据
                   .subscribe(new Consumer<Integer>() {
                       @Override
                       public void accept(Integer integer) {
                           Log.e("Alee",String.valueOf(integer));//打印 1 3 5
                       }
                   });
   ```

4. **takeLast**

   只发射最后的N项数据，或者一定时间内的数据。

   ```java
   Observable.just(1,3,5,7,9)
                   .takeLast(3)//取最后3项数据
                   .subscribe(new Consumer<Integer>() {
                       @Override
                       public void accept(Integer integer) {
                           Log.e("Alee",String.valueOf(integer)); //打印 5 7 9
                       }
                   });
   ```

5. **takeWhile**

   发射数据，直到你指定的条件不再满足后，停止发射。

   ```java
   Observable.just(1,2,3,4,5)
                   .takeWhile(new Predicate<Integer>() {
                       @Override
                       public boolean test(Integer integer) {
                           return integer != 3;
                       }
                   }).subscribe(new Consumer<Integer>() {
               @Override
               public void accept(Integer integer) {
                   Log.e("Alee",String.valueOf(integer)); //打印 1 2
               }
           });
   ```

6. **first**

   只发射第一项数据。需要指定默认值

   ```java
   Observable.just("A","B","C")
                   .first("Def")
                   .subscribe(new Consumer<String>() {
                       @Override
                       public void accept(String s) {
                           Log.e("Alee",s); //打印A
                       }
                   });
   ```

7. **last**

   只发射最后一项数据。需要指定默认值

   ```java
   Observable.just("A","B","C")
                   .last("Def")
                   .subscribe(new Consumer<String>() {
                       @Override
                       public void accept(String s) {
                           Log.e("Alee",s);//打印 C
                       }
                   });
   ```

8. **skip**

   跳过开始的N项数据或者一定时间内的数据。

   ```java
   Observable.just(1,2,3,4,5)
                   .skip(2)
                   .subscribe(new Consumer<Integer>() {
                       @Override
                       public void accept(Integer integer) {
                           Log.e("Alee",String.valueOf(integer)); //打印 3 4 5
                       }
                   });
   ```

9. **skipLast**

   跳过最后的N项数据或者一定时间内的数据。

   ```java
   Observable.just("1","2","3","4")
                   .skipLast(2)
                   .subscribe(new Consumer<String>() {
                       @Override
                       public void accept(String s) {
                           Log.e("Alee",s);//打印 1 2
                       }
                   });
   ```

10. **elementAt**

    发射某一项数据，如果超过了范围则可以指定默认值

    ```java
    Observable.just(1,2,3,4,5)
                    .elementAt(3)
                    .subscribe(new Consumer<Integer>() {
                        @Override
                        public void accept(Integer integer) {
                            Log.e("Alee",String.valueOf(integer));//打印 4
                        }
                    });
    ```

11. **elementAtOrError**

    发射某一项数据，如果超过了范围则发送一个NoSuchElementException的Error通知。

    ```java
    Observable.just(1,2,3,4,5)
                    .elementAtOrError(6)
                    .subscribe(new BiConsumer<Integer, Throwable>() {
                        @Override
                        public void accept(Integer integer, Throwable throwable) {
                            //打印 java.util.NoSuchElementException
                            Log.e("Alee",String.valueOf(throwable.toString()));
                        }
                    });
    ```

12. **ignoreElements**

    丢弃所有数据，只发射错误或者正常终于的通知。

13. **distinct**

    过滤重复数据。

    ```java
    Observable.just(1,2,3,2,4,2,3,4,5,9)
                    .distinct()
                    .subscribe(new Consumer<Integer>() {
                        @Override
                        public void accept(Integer integer) {
                            Log.e("Alee",String.valueOf(integer));// 打印 1 2 3 4 5 9
                        }
                    });
    ```

14. **distinctUntilChanged**

    过滤连续重复的数据。

    ```java
    Observable.just(1,2,2,2,4,2,3,4,5,9)
                    .distinctUntilChanged()
                    .subscribe(new Consumer<Integer>() {
                        @Override
                        public void accept(Integer integer) {
                            Log.e("Alee",String.valueOf(integer));// 打印 1 2 4 2 3 4 5 9
                        }
                    });
    ```

15. **throttleFirst**

    一定时间内取第一次发射的事件。可用于防止按钮在一段时间内重复点击(防抖动)

    ```java
    Observable.create(new ObservableOnSubscribe<Integer>() {
                @Override
                public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {
                    for (int i = 0; i < 100; i++) {
                        emitter.onNext(i);
                        Thread.sleep(10); //每发送一个事件，休眠10毫秒
                    }
                    emitter.onComplete();
                }
            }).throttleFirst(100,TimeUnit.MILLISECONDS) //取每100毫秒内第一次发射的事件
                    .subscribe(new Consumer<Integer>() {
                        @Override
                        public void accept(Integer integer) {
                            Log.e("Alee",String.valueOf(integer));
                        }
                    });
    ```

    打印结果

    ```java
    08-21 09:54:26.633 9038-9038/com.aleej.demo E/Alee: 0
    08-21 09:54:26.735 9038-9038/com.aleej.demo E/Alee: 10
    08-21 09:54:26.836 9038-9038/com.aleej.demo E/Alee: 20
    08-21 09:54:26.937 9038-9038/com.aleej.demo E/Alee: 30
    08-21 09:54:27.039 9038-9038/com.aleej.demo E/Alee: 40
    08-21 09:54:27.142 9038-9038/com.aleej.demo E/Alee: 50
    08-21 09:54:27.244 9038-9038/com.aleej.demo E/Alee: 60
    08-21 09:54:27.347 9038-9038/com.aleej.demo E/Alee: 70
    08-21 09:54:27.450 9038-9038/com.aleej.demo E/Alee: 80
    08-21 09:54:27.552 9038-9038/com.aleej.demo E/Alee: 90
    ```

16. **throttleWithTimeout/debounce**

    这两个操作符都表示发射数据时，如果两次数据的发射间隔小于指定的时间，则会丢弃前一次的数据，直到指定时间段内都没有新数据发射时才进行发射。

    > 其throttleWithTimeout内部也是调用debounce操作符来实现

    ```java
    Observable.create(new ObservableOnSubscribe<Integer>() {
                @Override
                public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {
                    for (int i = 0; i < 100; i++) {
                        emitter.onNext(i);
                        Thread.sleep(10); //每发送一个事件，休眠10毫秒
                    }
                    Thread.sleep(111);
                    emitter.onNext(100);
                    emitter.onComplete();
                }
            }).throttleWithTimeout(100,TimeUnit.MILLISECONDS)
                    .subscribe(new Consumer<Integer>() {
                        @Override
                        public void accept(Integer integer) {
                            Log.e("Alee",String.valueOf(integer)); //打印 99 100
                        }
                    });
    ```

17. **sample/throttleLast**

    一定时间内取最后一次发射的事件。

    > throttleLast内部也是采用sample操作符来实现

    ```java
    Observable.create(new ObservableOnSubscribe<Integer>() {
                @Override
                public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {
                    for (int i = 0; i < 100; i++) {
                        emitter.onNext(i);
                        Thread.sleep(10); //每发送一个事件，休眠10毫秒
                    }
                    emitter.onComplete();
                }
            }).throttleLast(100,TimeUnit.MILLISECONDS) //取每100毫秒内最后一次发射的事件
                    .subscribe(new Consumer<Integer>() {
                        @Override
                        public void accept(Integer integer) {
                            Log.e("Alee",String.valueOf(integer));
                        }
                    });
    ```

    打印结果

    ```java
    08-21 10:24:52.545 11096-11249/com.aleej.demo E/Alee: 9
    08-21 10:24:52.645 11096-11249/com.aleej.demo E/Alee: 19
    08-21 10:24:52.745 11096-11249/com.aleej.demo E/Alee: 29
    08-21 10:24:52.845 11096-11249/com.aleej.demo E/Alee: 39
    08-21 10:24:52.945 11096-11249/com.aleej.demo E/Alee: 49
    08-21 10:24:53.045 11096-11249/com.aleej.demo E/Alee: 59
    08-21 10:24:53.145 11096-11249/com.aleej.demo E/Alee: 68
    08-21 10:24:53.245 11096-11249/com.aleej.demo E/Alee: 78
    08-21 10:24:53.345 11096-11249/com.aleej.demo E/Alee: 88
    08-21 10:24:53.445 11096-11249/com.aleej.demo E/Alee: 98
    ```

18. **timeout**

    如果原始Observable过了指定的一段时长没有发射任何数据，则发送一个TimeoutException的异常通知或者使用备用的Observable发射数据。

    ```java
    Observable.create(new ObservableOnSubscribe<Integer>() {
                @Override
                public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {
                    Thread.sleep(120);
                    emitter.onNext(1);
                    emitter.onComplete();
                }
            }).timeout(100,TimeUnit.MILLISECONDS,Observable.just(9))
                    .subscribe(new Consumer<Integer>() {
                                   @Override
                                   public void accept(Integer integer) {
                                       Log.e("Alee", String.valueOf(integer));
                                   }
                               },
                            new Consumer<Throwable>() {
                                @Override
                                public void accept(Throwable throwable) throws Exception {
                                    Log.e("Alee", throwable.toString());
                                }
                            });
    ```

    打印结果

    ```java
    08-21 10:38:40.452 12430-12464/com.aleej.demo E/Alee: 9
    ```



## 条件/布尔操作

1. **all**

   判断所有的数据项是否都满足指定的条件。都满足才发射true，否则发射false

   ```java
   Observable.just(1,2,3,4,5)
                   .all(new Predicate<Integer>() {
                       @Override
                       public boolean test(Integer integer) {
                           return integer > 0 && integer < 5;
                       }
                   })
                   .subscribe(new Consumer<Boolean>() {
                       @Override
                       public void accept(Boolean aBoolean) {
                           Log.e("Alee",aBoolean.toString()); //打印false
                       }
                   });
   ```

2. **any**

   判断是否存在某一项满足指定的条件。只要存在则发射true，否则发射false，如果原始Observable没发射任何事件，则默认发射false。

   ```java
   Observable.just(1,2,3,4,5)
                   .any(new Predicate<Integer>() {
                       @Override
                       public boolean test(Integer integer) {
                           return integer > 0 && integer < 5;
                       }
                   })
                   .subscribe(new Consumer<Boolean>() {
                       @Override
                       public void accept(Boolean aBoolean) {
                           Log.e("Alee",aBoolean.toString()); //打印true
                       }
                   });
   ```

3. **contains**

   判断在发射的所有数据项中是否包含指定的元素。内部调用的any操作符来实现。

   ```java
   Observable.just(2,8,2,5,6)
                   .contains(6)
                   .subscribe(new Consumer<Boolean>() {
                       @Override
                       public void accept(Boolean aBoolean) {
                           Log.e("Alee",aBoolean.toString()); //打印true
                       }
                   });
   ```

4. **sequenceEqual**

   判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）

   ```java
   Observable.sequenceEqual(Observable.just(1,2,3),Observable.just(1,2,3))
                   .subscribe(new Consumer<Boolean>() {
                       @Override
                       public void accept(Boolean aBoolean) {
                           Log.e("Alee",aBoolean.toString()); //打印true
                       }
                   });
   
   Observable.sequenceEqual(Observable.just(1,2,3),Observable.just(3,2,1))
                   .subscribe(new Consumer<Boolean>() {
                       @Override
                       public void accept(Boolean aBoolean) {
                           Log.e("Alee",aBoolean.toString()); //打印false
                       }
                   });
   ```

5. **isEmpty**

   用于判断原始Observable发射完毕时，有没有发射数据。有发射数据则发射false，如果只收到了onComplete通知则发射true。

   ```java
   Observable.create(new ObservableOnSubscribe<Integer>() {
               @Override
               public void subscribe(ObservableEmitter<Integer> emitter) {
                   emitter.onComplete();
               }
           }).isEmpty().subscribe(new Consumer<Boolean>() {
               @Override
               public void accept(Boolean aBoolean) {
                   Log.e("Alee",aBoolean.toString()); //打印true
               }
           });
   ```

6. **ambArray**

   给定多个Observable，选择第一个发射数据的Observable进行处理，其他Observable则被抛弃。

   ```java
   Observable.ambArray(Observable.timer(1,TimeUnit.SECONDS),Observable.just(7L,8L,9L))
                   .subscribe(new Consumer<Long>() {
                       @Override
                       public void accept(Long aLong) {
                           Log.e("Alee",aLong.toString()); //打印7 8 9
                       }
                   });
   ```

7. **switchIfEmpty**

   如果原始Observable正常终止后没有发射任何数据，就使用备用的Observable发射数据。

   ```java
   Observable<Integer> observable = Observable.empty();
           observable.switchIfEmpty(Observable.just(1,2,3))
                   .subscribe(new Consumer<Integer>() {
                       @Override
                       public void accept(Integer integer) {
                           Log.e("Alee",integer.toString()); //打印 1 2 3
                       }
                   });
   ```

   